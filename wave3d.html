<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D 柔光粒子干涉</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050510; font-family: 'Segoe UI', sans-serif; transition: background-color 0.8s ease; }
        canvas { display: block; }

        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 280px;
            /* 移动端防溢出 */
            max-width: calc(100% - 40px); 
            background: rgba(15, 15, 25, 0.85);
            padding: 0 22px; /* Padding调整，由内部元素控制垂直间距 */
            border-radius: 16px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255,255,255,0.08);
            color: #eee;
            transition: all 0.3s ease;
            overflow: hidden; /* 关键：隐藏收起的内容 */
        }
        
        body.light-mode #controls {
            background: rgba(255, 255, 255, 0.8);
            color: #444;
            border: 1px solid rgba(0,0,0,0.05);
            box-shadow: 0 10px 40px rgba(0,0,0,0.1);
        }

        /* 标题栏布局 */
        .header-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 60px; /* 固定高度作为点击区域 */
            cursor: pointer;
            border-bottom: 1px solid transparent;
            transition: border-color 0.3s;
        }
        
        /* 收起时显示分割线 */
        #controls:not(.collapsed) .header-bar {
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        body.light-mode #controls:not(.collapsed) .header-bar {
            border-bottom: 1px solid rgba(0,0,0,0.1);
        }

        h3 { 
            margin: 0; 
            font-size: 15px; 
            letter-spacing: 2px; 
            text-transform: uppercase; 
            opacity: 0.9;
            pointer-events: none; /* 让点击穿透给父级 */
        }

        /* 折叠按钮图标 */
        #toggleIcon {
            font-size: 12px;
            transition: transform 0.3s ease;
            opacity: 0.7;
        }

        /* 收起状态下的图标旋转 */
        #controls.collapsed #toggleIcon {
            transform: rotate(-90deg);
        }
        
        /* 内容区域容器 - 用于动画 */
        .content-wrapper {
            max-height: 600px; /* 足够放下所有内容的高度 */
            opacity: 1;
            padding-bottom: 22px;
            padding-top: 15px;
            transition: max-height 0.4s cubic-bezier(0.4, 0, 0.2, 1), 
                        opacity 0.3s ease,
                        padding 0.3s ease;
        }

        /* 收起状态 */
        #controls.collapsed .content-wrapper {
            max-height: 0;
            opacity: 0;
            padding-top: 0;
            padding-bottom: 0;
            overflow: hidden;
        }

        .control-group { margin-bottom: 14px; }
        
        label { 
            display: flex; 
            justify-content: space-between; 
            font-size: 11px; 
            margin-bottom: 6px; 
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            opacity: 0.7;
        }
        
        select {
            width: 100%;
            padding: 8px;
            border-radius: 6px;
            border: 1px solid rgba(255,255,255,0.2);
            background: rgba(0,0,0,0.2);
            color: #fff;
            margin-bottom: 5px;
            cursor: pointer;
            outline: none;
            font-size: 12px;
        }

        body.light-mode select {
            background: rgba(255,255,255,0.8);
            color: #333;
            border: 1px solid #ccc;
        }

        input[type=range] { width: 100%; cursor: pointer; height: 4px; border-radius: 2px; accent-color: #00e5ff;}
        
        .divider { height: 1px; background: rgba(255,255,255,0.1); margin: 18px 0; }
        body.light-mode .divider { background: rgba(0,0,0,0.1); }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="controls">
        <!-- 标题栏变为可点击区域 -->
        <div class="header-bar" id="headerToggle">
            <h3>Soft Wave Lab</h3>
            <span id="toggleIcon">▼</span>
        </div>
        
        <!-- 所有控件包裹在 wrapper 中以便折叠 -->
        <div class="content-wrapper">
            <div class="control-group">
                <label>环境 (Environment)</label>
                <select id="bgSelect">
                    <option value="dark">深空 (Deep Space)</option>
                    <option value="light">极简白 (Studio Light)</option>
                </select>
            </div>

            <div class="control-group">
                <label>主题 (Theme)</label>
                <select id="themeSelect">
                    <option value="dream">梦幻极光 (Aurora)</option>
                    <option value="sunset">落日余晖 (Sunset)</option>
                    <option value="ocean">深海荧光 (Bioluminescence)</option>
                </select>
            </div>

            <div class="divider"></div>

            <div class="control-group">
                <label>波源间距 (Separation)</label>
                <input type="range" id="separation" min="0" max="50" value="20" step="0.5">
            </div>
            <div class="control-group">
                <label>频率 (Frequency)</label>
                <input type="range" id="frequency" min="1" max="15" value="5" step="0.1">
            </div>
            <div class="control-group">
                <label>振幅 (Amplitude)</label>
                <input type="range" id="amplitude" min="0" max="8" value="3.5" step="0.1">
            </div>
            <div class="control-group">
                <label>波速 (Speed)</label>
                <input type="range" id="speed" min="0" max="15" value="4" step="0.1">
            </div>

            <div class="divider"></div>

            <div class="control-group">
                <label>粒子柔光大小 (Soft Size)</label>
                <input type="range" id="pSize" min="5" max="40" value="18" step="1">
            </div>
            <div class="control-group">
                <label>密度 (Density)</label>
                <input type="range" id="density" min="100" max="300" value="180" step="10">
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- 简单的 UI 收起逻辑 ---
        const headerToggle = document.getElementById('headerToggle');
        const controlsDiv = document.getElementById('controls');
        
        // 默认为展开，点击切换
        headerToggle.addEventListener('click', () => {
            controlsDiv.classList.toggle('collapsed');
        });
        
        // 移动端检测：如果是窄屏，自动收起面板
        if (window.innerWidth < 600) {
            controlsDiv.classList.add('collapsed');
        }

        // --- 柔和配色方案 ---
        const COLOR_THEMES = {
            dream: {
                peak: new THREE.Color(0x00ffff),   // 青
                trough: new THREE.Color(0xaa00ff), // 紫
                node: new THREE.Color(0x020210)    // 深蓝
            },
            sunset: {
                peak: new THREE.Color(0xffaa00),   // 金黄
                trough: new THREE.Color(0xff0055), // 玫红
                node: new THREE.Color(0x200505)    // 暗褐
            },
            ocean: {
                peak: new THREE.Color(0x44ffaa),   // 薄荷绿
                trough: new THREE.Color(0x0066ff), // 宝蓝
                node: new THREE.Color(0x001122)    // 深海色
            }
        };

        // --- 场景 ---
        const scene = new THREE.Scene();
        const darkColor = new THREE.Color(0x050510);
        const lightColor = new THREE.Color(0xfbfbfb); // 柔和白
        
        scene.background = darkColor; 
        scene.fog = new THREE.FogExp2(0x050510, 0.02); 

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 60, 80);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.4;

        // 网格
        const gridHelper = new THREE.GridHelper(150, 60, 0x333333, 0x111111);
        gridHelper.position.y = -3;
        gridHelper.material.opacity = 0.2;
        gridHelper.material.transparent = true;
        scene.add(gridHelper);

        // --- Shader ---
        
        const vertexShader = `
            uniform float uTime;
            uniform float uFreq;
            uniform float uAmp;
            uniform float uSpeed;
            uniform float uSize;
            uniform vec3 uSource1;
            uniform vec3 uSource2;

            varying float vElevation;

            void main() {
                vec4 modelPosition = modelMatrix * vec4(position, 1.0);

                float d1 = distance(modelPosition.xz, uSource1.xz);
                float d2 = distance(modelPosition.xz, uSource2.xz);

                float wave1 = sin(d1 * uFreq - uTime * uSpeed);
                float wave2 = sin(d2 * uFreq - uTime * uSpeed);
                
                float elevation = wave1 + wave2;

                modelPosition.y += elevation * uAmp;
                vElevation = elevation; 

                vec4 viewPosition = viewMatrix * modelPosition;
                vec4 projectedPosition = projectionMatrix * viewPosition;

                gl_Position = projectedPosition;
                gl_PointSize = uSize * (200.0 / -viewPosition.z);
            }
        `;

        const fragmentShader = `
            uniform vec3 uColorPeak;
            uniform vec3 uColorTrough;
            uniform vec3 uColorNode;
            uniform float uAlphaMultiplier; 

            varying float vElevation;

            void main() {
                float dist = distance(gl_PointCoord, vec2(0.5));
                float strength = 1.0 - (dist * 2.0);
                strength = clamp(strength, 0.0, 1.0);
                strength = pow(strength, 3.0); 

                vec3 finalColor;
                float intensity = 0.0;

                if (vElevation > 0.0) {
                    float t = clamp(vElevation / 1.5, 0.0, 1.0);
                    finalColor = mix(uColorNode, uColorPeak, t);
                    intensity = 0.2 + t * 0.8;
                } else {
                    float t = clamp(abs(vElevation) / 1.5, 0.0, 1.0);
                    finalColor = mix(uColorNode, uColorTrough, t);
                    intensity = 0.2 + t * 0.8;
                }

                float alpha = strength * intensity * uAlphaMultiplier;
                gl_FragColor = vec4(finalColor, alpha); 
            }
        `;

        const uniforms = {
            uTime: { value: 0 },
            uFreq: { value: 2.5 },
            uAmp: { value: 1.75 },
            uSpeed: { value: 4.0 },
            uSize: { value: 18.0 }, 
            uSource1: { value: new THREE.Vector3(-10, 0, 0) },
            uSource2: { value: new THREE.Vector3(10, 0, 0) },
            uColorPeak: { value: COLOR_THEMES.dream.peak },
            uColorTrough: { value: COLOR_THEMES.dream.trough },
            uColorNode: { value: COLOR_THEMES.dream.node },
            uAlphaMultiplier: { value: 1.0 }
        };

        const material = new THREE.ShaderMaterial({
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            uniforms: uniforms,
            transparent: true,
            depthWrite: false, 
            blending: THREE.AdditiveBlending 
        });

        let particles, geometry;
        const planeSize = 120; 

        function createParticles(density) {
            if (particles) {
                scene.remove(particles);
                geometry.dispose();
            }
            geometry = new THREE.PlaneGeometry(planeSize, planeSize, density, density);
            geometry.rotateX(-Math.PI / 2);
            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        // --- 交互逻辑 ---
        
        const ui = {
            bg: document.getElementById('bgSelect'),
            theme: document.getElementById('themeSelect'),
            sep: document.getElementById('separation'),
            freq: document.getElementById('frequency'),
            amp: document.getElementById('amplitude'),
            speed: document.getElementById('speed'),
            pSize: document.getElementById('pSize'),
            density: document.getElementById('density')
        };

        function updatePhysics() {
            const sep = parseFloat(ui.sep.value);
            uniforms.uSource1.value.set(-sep, 0, 0);
            uniforms.uSource2.value.set(sep, 0, 0);
            uniforms.uFreq.value = parseFloat(ui.freq.value) * 0.2;
            uniforms.uAmp.value = parseFloat(ui.amp.value) * 0.5;
            uniforms.uSpeed.value = parseFloat(ui.speed.value);
            uniforms.uSize.value = parseFloat(ui.pSize.value);
        }

        function updateTheme() {
            const theme = COLOR_THEMES[ui.theme.value];
            uniforms.uColorPeak.value = theme.peak;
            uniforms.uColorTrough.value = theme.trough;
            
            if (ui.bg.value === 'light') {
                uniforms.uColorNode.value = new THREE.Color(0xcccccc);
            } else {
                uniforms.uColorNode.value = theme.node;
            }
        }

        function updateBg() {
            if (ui.bg.value === 'light') {
                scene.background = lightColor;
                scene.fog = new THREE.FogExp2(0xfbfbfb, 0.02);
                document.body.classList.add('light-mode');
                
                material.blending = THREE.NormalBlending; 
                uniforms.uAlphaMultiplier.value = 0.8; 
            } else {
                scene.background = darkColor;
                scene.fog = new THREE.FogExp2(0x050510, 0.02);
                document.body.classList.remove('light-mode');
                
                material.blending = THREE.AdditiveBlending;
                uniforms.uAlphaMultiplier.value = 1.0;
            }
            updateTheme();
        }

        let debounce;
        ui.density.addEventListener('input', () => {
            clearTimeout(debounce);
            debounce = setTimeout(() => createParticles(parseInt(ui.density.value)), 100);
        });

        [ui.sep, ui.freq, ui.amp, ui.speed, ui.pSize].forEach(el => el.addEventListener('input', updatePhysics));
        ui.theme.addEventListener('change', updateTheme);
        ui.bg.addEventListener('change', updateBg);
        
        // 阻止点击面板时旋转镜头
        document.getElementById('controls').addEventListener('mousedown', (e) => e.stopPropagation());
        // 手机触摸时也阻止穿透
        document.getElementById('controls').addEventListener('touchstart', (e) => e.stopPropagation(), {passive: false});

        renderer.domElement.addEventListener('mousedown', () => controls.autoRotate = false);
        renderer.domElement.addEventListener('touchstart', () => controls.autoRotate = false);

        // 初始化
        createParticles(180);
        updatePhysics();
        updateBg();

        const clock = new THREE.Clock();
        function animate() {
            uniforms.uTime.value = clock.getElapsedTime();
            controls.update();
            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>
</html>

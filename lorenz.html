<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>晶莹洛伦兹 - 终极版</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
        /* 简单美化一下 lil-gui 的位置，虽然它默认在右上角 */
        .lil-gui { 
            font-family: 'Segoe UI', sans-serif !important;
        }
    </style>
    <!-- 引入 Three.js 和 lil-gui -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "lil-gui": "https://unpkg.com/lil-gui@0.19.1/dist/lil-gui.esm.min.js"
            }
        }
    </script>
</head>
<body>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import GUI from 'lil-gui';

        // --- 1. 基础场景 ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050508); // 极深的蓝黑色背景
        scene.fog = new THREE.FogExp2(0x050508, 0.002); // 雾化，让背景星辰有远近感

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.set(0, -80, 40);

        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.3;
        controls.target.set(0, 0, 25);

        // --- 2. 纹理生成 ---
        // A. 洛伦兹粒子的纹理 (锐利，像钻石)
        function createCrystalTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const g = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
            g.addColorStop(0, 'rgba(255,255,255,1)');
            g.addColorStop(0.3, 'rgba(230,240,255,0.4)'); // 稍微带点蓝
            g.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = g;
            ctx.fillRect(0, 0, 32, 32);
            return new THREE.CanvasTexture(canvas);
        }

        // B. 背景星尘的纹理 (柔和)
        function createStarTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const g = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
            g.addColorStop(0, 'rgba(255,255,255,0.8)');
            g.addColorStop(0.5, 'rgba(255,255,255,0.1)');
            g.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = g;
            ctx.fillRect(0, 0, 32, 32);
            return new THREE.CanvasTexture(canvas);
        }

        // --- 3. 背景星空系统 ---
        const starCount = 2000;
        const starGeo = new THREE.BufferGeometry();
        const starPos = new Float32Array(starCount * 3);
        const starSizes = new Float32Array(starCount);

        for(let i=0; i<starCount; i++) {
            // 在远处随机分布
            const r = 100 + Math.random() * 200; // 半径 100~300
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            
            starPos[i*3] = r * Math.sin(phi) * Math.cos(theta);
            starPos[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
            starPos[i*3+2] = r * Math.cos(phi);

            starSizes[i] = Math.random() * 1.5; // 大小不一
        }
        starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
        starGeo.setAttribute('size', new THREE.BufferAttribute(starSizes, 1));

        const starMat = new THREE.PointsMaterial({
            size: 1,
            map: createStarTexture(),
            transparent: true,
            opacity: 0.6,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });
        const starSystem = new THREE.Points(starGeo, starMat);
        scene.add(starSystem);


        // --- 4. 洛伦兹粒子系统 (核心) ---
        
        // 配置参数对象 (用于 GUI)
        const params = {
            count: 15000,       // 默认粒子数
            size: 0.5,          // 粒子大小
            opacity: 0.7,       // 透明度
            speed: 1.0,         // 速度倍率
            colorSat: 0.8,      // 饱和度
            reset: () => initLorenzSystem() // 重置按钮
        };

        let lorenzSystem, positions, colors, states;
        const lorenzMat = new THREE.PointsMaterial({
            size: params.size,
            map: createCrystalTexture(),
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true,
            opacity: params.opacity
        });

        // 初始化/重置洛伦兹系统的函数
        function initLorenzSystem() {
            // 如果已存在，先移除旧的，释放内存
            if(lorenzSystem) {
                scene.remove(lorenzSystem);
                lorenzSystem.geometry.dispose();
            }

            const count = params.count;
            const geo = new THREE.BufferGeometry();
            positions = new Float32Array(count * 3);
            colors = new Float32Array(count * 3);
            states = [];

            for(let i=0; i<count; i++) {
                // 初始位置集中在一起，产生爆炸效果
                const startX = (Math.random() - 0.5) * 5;
                const startY = (Math.random() - 0.5) * 5;
                const startZ = 25 + (Math.random() - 0.5) * 5;
                
                states.push({ x: startX, y: startY, z: startZ });
                
                positions[i*3] = startX;
                positions[i*3+1] = startY;
                positions[i*3+2] = startZ;
            }
            
            geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            lorenzSystem = new THREE.Points(geo, lorenzMat);
            scene.add(lorenzSystem);
        }

        // 初次运行
        initLorenzSystem();


        // --- 5. GUI 面板设置 ---
        const gui = new GUI({ title: '控制面板' });
        
        // 粒子设置文件夹
        const folder1 = gui.addFolder('粒子外观');
        folder1.add(params, 'count', 1000, 40000, 1000).name('粒子数量').onFinishChange(initLorenzSystem); // 只有松开鼠标才触发重置
        folder1.add(params, 'size', 0.1, 3.0).name('颗粒大小').onChange(v => lorenzMat.size = v);
        folder1.add(params, 'opacity', 0.1, 1.0).name('亮度/透明度').onChange(v => lorenzMat.opacity = v);
        
        // 动画设置文件夹
        const folder2 = gui.addFolder('动画参数');
        folder2.add(params, 'speed', 0.0, 3.0).name('流动速度');
        folder2.add(params, 'colorSat', 0.0, 1.0).name('色彩饱和度');
        
        folder1.open();
        folder2.open();
        
        // 移动端/小屏幕自动收起
        if (window.innerWidth < 600) gui.close();


        // --- 6. 动画循环 ---
        // 洛伦兹常数
        const sigma = 10;
        const rho = 28;
        const beta = 8/3;
        const baseDt = 0.005; 

        const tempColor = new THREE.Color();
        let time = 0;

        function animate() {
            requestAnimationFrame(animate);
            
            // A. 背景星空缓慢旋转
            starSystem.rotation.y += 0.0005;
            starSystem.rotation.x += 0.0002;

            // B. 洛伦兹粒子更新
            time += 0.001 * params.speed;
            const currentDt = baseDt * params.speed;

            if (lorenzSystem) {
                const posArr = lorenzSystem.geometry.attributes.position.array;
                const colArr = lorenzSystem.geometry.attributes.color.array;

                for(let i=0; i<params.count; i++) {
                    const s = states[i];
                    
                    // 物理计算
                    const dx = (sigma * (s.y - s.x)) * currentDt;
                    const dy = (s.x * (rho - s.z) - s.y) * currentDt;
                    const dz = (s.x * s.y - beta * s.z) * currentDt;

                    s.x += dx;
                    s.y += dy;
                    s.z += dz;

                    posArr[i*3] = s.x;
                    posArr[i*3+1] = s.y;
                    posArr[i*3+2] = s.z;

                    // 颜色计算
                    const speed = Math.sqrt(dx*dx + dy*dy + dz*dz);
                    
                    // 晶莹剔透的冷色调：基础青色(0.5) + Z轴偏移 + 时间微扰
                    // 颜色范围控制在 青(0.5) -> 蓝(0.66) -> 紫(0.75)
                    const hue = 0.55 + (s.z * 0.004) + (Math.sin(time * 0.5 + i*0.0001) * 0.1);
                    
                    // 亮度：速度越快越亮，静止时保持微光
                    const lightness = 0.4 + Math.min(0.5, speed * 0.3);
                    
                    tempColor.setHSL(hue % 1, params.colorSat, lightness);

                    colArr[i*3] = tempColor.r;
                    colArr[i*3+1] = tempColor.g;
                    colArr[i*3+2] = tempColor.b;
                }
                
                lorenzSystem.geometry.attributes.position.needsUpdate = true;
                lorenzSystem.geometry.attributes.color.needsUpdate = true;
            }

            controls.update();
            renderer.render(scene, camera);
        }

        animate();

        // 自适应窗口
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>

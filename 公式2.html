<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Math Particles: Final Clean</title>
    <style>
        /* --- 基础样式 --- */
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', 'Roboto', sans-serif; user-select: none; }
        #canvas-container { width: 100vw; height: 100vh; display: block; background: radial-gradient(circle at center, #0b0b15 0%, #000000 100%); }

        /* --- 左侧 UI 面板 --- */
        #ui-panel {
            position: absolute; top: 20px; left: 20px; width: 320px; max-height: 85vh;
            background: rgba(8, 12, 16, 0.85); backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(0, 255, 255, 0.15); border-radius: 8px;
            padding: 20px; box-shadow: 0 0 30px rgba(0,0,0,0.8);
            color: #fff; transition: transform 0.4s cubic-bezier(0.2, 1, 0.3, 1), opacity 0.4s;
            z-index: 100;
            overflow-y: auto;
            scrollbar-width: thin; scrollbar-color: #00ffff #222;
        }
        /* 自定义滚动条样式 */
        #ui-panel::-webkit-scrollbar { width: 6px; }
        #ui-panel::-webkit-scrollbar-track { background: rgba(0,0,0,0.3); }
        #ui-panel::-webkit-scrollbar-thumb { background: rgba(0, 255, 255, 0.5); border-radius: 3px; }
        #ui-panel::-webkit-scrollbar-thumb:hover { background: #00ffff; }

        #ui-panel.closed { transform: translateX(-380px); opacity: 0; pointer-events: none; }
        
        h1 { font-size: 18px; margin: 0 0 10px 0; text-transform: uppercase; letter-spacing: 2px; font-weight: 600;
             background: linear-gradient(90deg, #fff, #00ffff); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        
        #formula-box { font-family: 'Consolas', 'Courier New', monospace; font-size: 11px; color: #6be; background: rgba(0,0,0,0.5); 
                       padding: 10px; border-left: 2px solid #00ffff; margin-bottom: 15px; min-height: 45px; line-height: 1.4; border-radius: 4px; }
        
        .btn-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        .shape-btn { background: rgba(255, 255, 255, 0.04); border: 1px solid rgba(255, 255, 255, 0.1); 
                     color: #aaa; padding: 10px 5px; border-radius: 4px; cursor: pointer; font-size: 12px; text-align: center; transition: all 0.2s ease; }
        .shape-btn:hover { background: rgba(0, 255, 255, 0.15); color: #fff; border-color: rgba(0, 255, 255, 0.3); transform: translateY(-2px); }
        .shape-btn.active { background: rgba(0, 255, 255, 0.8); color: #000; font-weight: bold; box-shadow: 0 0 15px rgba(0,255,255,0.4); border-color: transparent; }

        /* --- 切换按钮 --- */
        #toggle-btn { position: absolute; top: 20px; left: 20px; width: 36px; height: 36px; 
                      background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 50%;
                      cursor: pointer; z-index: 99; display: flex; align-items: center; justify-content: center; 
                      color: white; transition: 0.3s; backdrop-filter: blur(4px); }
        #toggle-btn:hover { background: rgba(0, 255, 255, 0.3); transform: scale(1.1); }
        .icon-menu::before { content: "☰"; font-size: 16px; } .icon-close::before { content: "✕"; font-size: 14px; }
    </style>
    <!-- Import Map -->
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>
</head>
<body>

    <div id="toggle-btn" class="icon-close"></div>

    <div id="ui-panel">
        <h1 id="shape-title">Math Visualization</h1>
        <div id="formula-box"></div>
        <div class="btn-grid" id="btn-container"></div>
    </div>

    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        // ==========================================
        // 1. 系统配置
        // ==========================================
        const config = {
            particleCount: 70000, 
            baseSize: 2.5,
            morphSpeed: 0.05,
            explodeSpeed: 0.25,
            explodeRange: 35.0,
            rotationSpeed: 0.12,
            blinkSpeed: 1.5,
            starCount: 3500
        };

        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000005, 0.02);

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1, 18);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = config.rotationSpeed;

        // ==========================================
        // 2. 数学函数库 (严格作用域版)
        // ==========================================
        const functions = [
            { 
                name: "3D Heart (心形)", 
                formula: "x = 16sin³(u)sin²(v)<br>y = (13cos(u)-5cos(2u)...)sin²(v)<br>z = 10cos(v)", 
                getPoint: (u, v, t) => {
                    const uRad = u * 2 * Math.PI; 
                    const vRad = v * Math.PI; 
                    const s = 0.3;
                    const x = s * 16 * Math.pow(Math.sin(uRad), 3) * Math.pow(Math.sin(vRad), 2);
                    const y = s * (13*Math.cos(uRad)-5*Math.cos(2*uRad)-2*Math.cos(3*uRad)-Math.cos(4*uRad)) * Math.pow(Math.sin(vRad), 2);
                    const z = s * 10 * Math.cos(vRad);
                    // 交换 Y 和 Z 以便垂直站立
                    t.set(x, z, y); 
                }
            },
            { 
                name: "Sphere (球体)", 
                formula: "x = r sin(u) cos(v)<br>y = r sin(u) sin(v)<br>z = r cos(u)", 
                getPoint: (u, v, t) => {
                    const uRad = u * Math.PI; 
                    const vRad = v * 2 * Math.PI; 
                    const r = 4.5;
                    t.set(r*Math.sin(uRad)*Math.cos(vRad), r*Math.sin(uRad)*Math.sin(vRad), r*Math.cos(uRad));
                }
            },
            { 
                name: "Double Helix (双螺旋DNA)", 
                formula: "Phase Shifted Helices<br>R(u) = 1.5 + offset", 
                getPoint: (u, v, t) => {
                    const side = (u > 0.5) ? 1 : 0;
                    const phase = side * Math.PI;
                    const uLocal = (u - 0.5 * side) * 2.0; 
                    const r = 1.6 + (uLocal - 0.5) * 0.6; 
                    const angle = v * 8.0 * Math.PI; 
                    const h = (v - 0.5) * 14.0; 
                    t.set(r * Math.cos(angle + phase), h, r * Math.sin(angle + phase));
                }
            },
            { 
                name: "Torus (圆环)", 
                formula: "x = (R+r cos(v))cos(u)<br>y = (R+r cos(v))sin(u)<br>z = r sin(v)", 
                getPoint: (u, v, t) => {
                    const uRad = u * 2 * Math.PI; 
                    const vRad = v * 2 * Math.PI; 
                    const R = 3.5;
                    const r = 1.3;
                    t.set((R+r*Math.cos(vRad))*Math.cos(uRad), (R+r*Math.cos(vRad))*Math.sin(uRad), r*Math.sin(vRad));
                }
            },
            { 
                name: "Klein Bottle (克莱因瓶)", 
                formula: "Parametric Figure-8 Immersion", 
                getPoint: (u, v, t) => {
                    const uRad = u * 2 * Math.PI; 
                    const vRad = v * 2 * Math.PI; 
                    const r = 4.0 - 2.0 * Math.cos(uRad); 
                    const s = 0.6;
                    let x, y, z;
                    
                    if(uRad < Math.PI) { 
                        x = 6*Math.cos(uRad)*(1+Math.sin(uRad)) + r*Math.cos(uRad)*Math.cos(vRad); 
                        y = 16*Math.sin(uRad) + r*Math.sin(uRad)*Math.cos(vRad); 
                    } else { 
                        x = 6*Math.cos(uRad)*(1+Math.sin(uRad)) + r*Math.cos(vRad+Math.PI); 
                        y = 16*Math.sin(uRad); 
                    }
                    z = r*Math.sin(vRad); 
                    t.set(s*x, s*(y-2.0), s*z);
                }
            },
            { 
                name: "Roman Surface (罗马曲面)", 
                formula: "x = sin(2u)sin²(v)/2<br>y = sin(u)sin(2v)/2<br>z = cos(u)sin(2v)/2", 
                getPoint: (u, v, t) => {
                    const uRad = u * Math.PI; 
                    const vRad = v * Math.PI; 
                    const s = 5.0;
                    t.set(s*Math.sin(2*uRad)*Math.pow(Math.sin(vRad),2), s*Math.sin(uRad)*Math.sin(2*vRad), s*Math.cos(uRad)*Math.sin(2*vRad));
                }
            },
            { 
                name: "Conical Spiral (锥形螺旋)", 
                formula: "x = u cos(v), z = u sin(v), y = u", 
                getPoint: (u, v, t) => {
                    const r = (1.0 - u) * 6.0; 
                    const ang = v * 10.0 * Math.PI; 
                    const h = r - 3.0;
                    t.set(r * Math.cos(ang), h, r * Math.sin(ang));
                }
            },
            { 
                name: "Hyperbolic (马鞍面)", 
                formula: "y = x² - z² (Saddle Surface)", 
                getPoint: (u, v, t) => {
                    const x = (u - 0.5) * 4.0;
                    const z = (v - 0.5) * 4.0;
                    t.set(x, (x*x - z*z) * 0.5, z);
                }
            }
        ];

        // ==========================================
        // 3. 纹理与材质
        // ==========================================
        function createSharpTexture() {
            const c = document.createElement('canvas'); c.width=64; c.height=64;
            const ctx = c.getContext('2d');
            const g = ctx.createRadialGradient(32,32,0,32,32,32);
            g.addColorStop(0, 'rgba(255,255,255,1)');
            g.addColorStop(0.2, 'rgba(150,230,255,0.8)');
            g.addColorStop(0.4, 'rgba(0,0,0,0)');
            ctx.fillStyle = g; ctx.fillRect(0,0,64,64);
            
            ctx.strokeStyle = 'rgba(255,255,255,0.9)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(32, 6); ctx.lineTo(32, 58);
            ctx.moveTo(6, 32); ctx.lineTo(58, 32);
            ctx.stroke();
            return new THREE.CanvasTexture(c);
        }

        // ==========================================
        // 4. 主粒子系统构建
        // ==========================================
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(config.particleCount * 3);
        const targetPositions = new Float32Array(config.particleCount * 3);
        const colors = new Float32Array(config.particleCount * 3);
        const randoms = new Float32Array(config.particleCount);
        const uvs = [];
        
        const tempVec = new THREE.Vector3();
        const colorObj = new THREE.Color();

        // 初始化
        for(let i=0; i<config.particleCount; i++) {
            const u = Math.random(); const v = Math.random(); uvs.push({u,v});
            
            // 初始默认为 Sphere (index 1)
            functions[1].getPoint(u, v, tempVec); 
            positions[i*3]=tempVec.x; positions[i*3+1]=tempVec.y; positions[i*3+2]=tempVec.z;
            targetPositions[i*3]=tempVec.x; targetPositions[i*3+1]=tempVec.y; targetPositions[i*3+2]=tempVec.z;

            // 初始颜色
            const hue = 0.55 + u * 0.15; 
            colorObj.setHSL(hue, 0.8, 0.6);
            colors[i*3]=colorObj.r; colors[i*3+1]=colorObj.g; colors[i*3+2]=colorObj.b;

            randoms[i] = Math.random() * 100.0;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.setAttribute('aRandom', new THREE.BufferAttribute(randoms, 1));

        const mainMaterial = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uSize: { value: config.baseSize },
                uTexture: { value: createSharpTexture() },
                uBlinkSpeed: { value: config.blinkSpeed }
            },
            vertexShader: `
                attribute vec3 color;
                attribute float aRandom;
                uniform float uTime;
                uniform float uSize;
                uniform float uBlinkSpeed;
                varying vec3 vColor;
                varying float vAlpha;
                void main() {
                    vColor = color;
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    float blink = 0.5 + 0.5 * sin(uTime * uBlinkSpeed + aRandom);
                    // 距离衰减计算
                    gl_PointSize = uSize * blink * (250.0 / -mvPosition.z);
                    gl_Position = projectionMatrix * mvPosition;
                    vAlpha = blink;
                }
            `,
            fragmentShader: `
                uniform sampler2D uTexture;
                varying vec3 vColor;
                varying float vAlpha;
                void main() {
                    vec4 texColor = texture2D(uTexture, gl_PointCoord);
                    if (texColor.a < 0.01) discard;
                    gl_FragColor = vec4(vColor, texColor.a * vAlpha * 0.85);
                }
            `,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true
        });

        const particleSystem = new THREE.Points(geometry, mainMaterial);
        scene.add(particleSystem);

        // ==========================================
        // 5. 背景星空
        // ==========================================
        const starGeo = new THREE.BufferGeometry();
        const starPos = new Float32Array(config.starCount * 3);
        const starParams = new Float32Array(config.starCount * 2); 
        for(let i=0; i<config.starCount; i++) {
            const r = 40 + Math.random() * 80;
            const theta = Math.random() * Math.PI * 2; const phi = Math.acos(2*Math.random()-1);
            starPos[i*3] = r*Math.sin(phi)*Math.cos(theta);
            starPos[i*3+1] = r*Math.sin(phi)*Math.sin(theta);
            starPos[i*3+2] = r*Math.cos(phi);
            starParams[i*2] = 0.5 + Math.random()*2;
            starParams[i*2+1] = Math.random()*100; 
        }
        starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
        starGeo.setAttribute('params', new THREE.BufferAttribute(starParams, 2));

        const starMat = new THREE.ShaderMaterial({
            uniforms: { uTime: { value: 0 } },
            vertexShader: `
                attribute vec2 params;
                uniform float uTime;
                void main() {
                    vec4 mv = modelViewMatrix * vec4(position, 1.0);
                    float flicker = 0.5 + 0.5 * sin(uTime * 1.5 + params.y);
                    gl_PointSize = params.x * flicker * (300.0 / -mv.z);
                    gl_Position = projectionMatrix * mv;
                }
            `,
            fragmentShader: `
                void main() {
                    float d = distance(gl_PointCoord, vec2(0.5));
                    if(d>0.5) discard;
                    float a = 1.0 - d*2.0; a = pow(a, 2.0);
                    gl_FragColor = vec4(0.5, 0.7, 0.9, a * 0.5);
                }
            `,
            transparent: true, blending: THREE.AdditiveBlending, depthWrite: false
        });
        scene.add(new THREE.Points(starGeo, starMat));

        // ==========================================
        // 6. 交互与动画控制
        // ==========================================
        let currentFuncIdx = 1; 
        let isTransitioning = false;

        function updateUI(idx) {
            document.getElementById('shape-title').innerText = functions[idx].name;
            document.getElementById('formula-box').innerHTML = functions[idx].formula;
            document.querySelectorAll('.shape-btn').forEach(b => b.classList.remove('active'));
            document.getElementById(`btn-${idx}`).classList.add('active');
        }

        function switchShape(index) {
            if (isTransitioning || index === currentFuncIdx) return;
            isTransitioning = true;
            
            // 1. 爆炸
            for (let i = 0; i < config.particleCount; i++) {
                const r = config.explodeRange * (0.6 + Math.random()*0.8);
                const theta = Math.random()*Math.PI*2; const phi = Math.acos(2*Math.random()-1);
                targetPositions[i*3] = r*Math.sin(phi)*Math.cos(theta);
                targetPositions[i*3+1] = r*Math.sin(phi)*Math.sin(theta);
                targetPositions[i*3+2] = r*Math.cos(phi);
            }

            // 2. 重组
            setTimeout(() => {
                currentFuncIdx = index;
                updateUI(index);
                const func = functions[index];
                
                const baseHue = Math.random();
                for (let i = 0; i < config.particleCount; i++) {
                    func.getPoint(uvs[i].u, uvs[i].v, tempVec);
                    targetPositions[i*3] = tempVec.x; targetPositions[i*3+1] = tempVec.y; targetPositions[i*3+2] = tempVec.z;
                    
                    colorObj.setHSL((baseHue + uvs[i].u*0.2)%1, 0.8, 0.6);
                    geometry.attributes.color.setXYZ(i, colorObj.r, colorObj.g, colorObj.b);
                }
                geometry.attributes.color.needsUpdate = true;
                setTimeout(() => isTransitioning = false, 800);
            }, 600);
        }

        // 动态生成按钮
        const btnContainer = document.getElementById('btn-container');
        functions.forEach((f, i) => {
            const btn = document.createElement('div');
            btn.className = 'shape-btn'; 
            btn.id = `btn-${i}`; 
            btn.innerText = f.name.split(' (')[0];
            btn.onclick = () => switchShape(i);
            btnContainer.appendChild(btn);
        });
        updateUI(currentFuncIdx);

        // 面板收起/展开
        const toggleBtn = document.getElementById('toggle-btn');
        const uiPanel = document.getElementById('ui-panel');
        toggleBtn.onclick = () => {
            uiPanel.classList.toggle('closed');
            toggleBtn.className = uiPanel.classList.contains('closed') ? 'icon-menu' : 'icon-close';
        };

        // GUI 控制台
        const gui = new GUI({ title: '参数设置' });
        gui.domElement.style.top = '20px';
        const f1 = gui.addFolder('动画');
        f1.add(config, 'rotationSpeed', 0, 0.5).name('旋转速度').onChange(v=>controls.autoRotateSpeed=v);
        f1.add(config, 'explodeRange', 10, 60).name('爆炸力度');
        const f2 = gui.addFolder('视觉');
        f2.add(mainMaterial.uniforms.uSize, 'value', 0.5, 5.0).name('粒子大小'); 
        f2.add(mainMaterial.uniforms.uBlinkSpeed, 'value', 0, 10).name('闪烁频率');

        // 动画循环
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            controls.update();

            mainMaterial.uniforms.uTime.value = time;
            starMat.uniforms.uTime.value = time;

            const pos = geometry.attributes.position.array;
            let needsUpdate = false;
            
            // 使用 Math.pow 计算插值因子，保证帧率无关性
            // 限制 speed 的最小值防止 factor 异常
            // 这里拆分计算以提高一点点循环性能
            
            for(let i=0; i<config.particleCount; i++) {
                const idx = i*3;
                const tx=targetPositions[idx], ty=targetPositions[idx+1], tz=targetPositions[idx+2];
                const cx=pos[idx], cy=pos[idx+1], cz=pos[idx+2];
                const distSq = (tx-cx)*(tx-cx) + (ty-cy)*(ty-cy) + (tz-cz)*(tz-cz);
                
                if (distSq > 0.01) {
                    const speed = (distSq > 100) ? config.explodeSpeed : config.morphSpeed;
                    const factor = 1.0 - Math.pow(0.01, delta * speed * 3.0);
                    
                    pos[idx] += (tx-cx)*factor;
                    pos[idx+1] += (ty-cy)*factor;
                    pos[idx+2] += (tz-cz)*factor;
                    needsUpdate = true;
                }
            }
            if(needsUpdate) geometry.attributes.position.needsUpdate = true;

            if(!isTransitioning) {
                // 呼吸效果
                const freq = currentFuncIdx === 0 ? 3.0 : 1.0; 
                const amp = currentFuncIdx === 0 ? 0.05 : 0.02;
                const s = 1.0 + Math.sin(time * freq) * amp;
                particleSystem.scale.set(s,s,s);
            }

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        animate();
    </script>
</body>
</html>
